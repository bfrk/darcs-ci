{-# LANGUAGE MultiParamTypeClasses #-}
module Darcs.Patch.Witnesses.Square where

import Darcs.Prelude
import Data.Type.Equality

{- | The symmetry group of a square with 8 elements, presented as a relation
between the four corners.

@
   c ----- d
   |       |
   |       |
   |       |
   b ----- a
@

This group is generated by a rotation and a mirror image e.g.

> instance Square a b c d => Square b c d a
> instance Square a b c d => Square c b a d

Of course these instances would overlap. So we provide only instances where
the 4th corner is fixed to @'Squared' a b c@, where @a@ @b@ @c@ are the free
parameters.

-}
class Square a b c d where
  isSquare :: IsSquare a b c d

-- | Data type carrying evidence that @d@ is a 'Squared' of @a@, @b@, and @c@.
data IsSquare a b c d where
  U  :: Squared a b c :~: d -> IsSquare a b c d
  R1 :: Squared a b c :~: d -> IsSquare b c d a
  R2 :: Squared a b c :~: d -> IsSquare c d a b
  R3 :: Squared a b c :~: d -> IsSquare d a b c
  M  :: Squared a b c :~: d -> IsSquare c b a d
  M1 :: Squared a b c :~: d -> IsSquare b a d c
  M2 :: Squared a b c :~: d -> IsSquare a d c b
  M3 :: Squared a b c :~: d -> IsSquare d c b a

-- | From three corners, determine the fourth
data Squared a b c

-- 4 rotations
instance Square a b c (Squared a b c) -- Unit = R^4
  where isSquare = U Refl
instance Square b c (Squared a b c) a -- R
  where isSquare = R1 Refl
instance Square c (Squared a b c) a b -- R^2
  where isSquare = R2 Refl
instance Square (Squared a b c) a b c -- R^3
  where isSquare = R3 Refl

-- mirror images along the 4 symmetry axes
instance Square c b a (Squared a b c) -- M = swap a/c
  where isSquare = M Refl
instance Square b a (Squared a b c) c -- M1 = M;R = swap a/b, c/d
  where isSquare = M1 Refl
instance Square a (Squared a b c) c b -- M2 = M;R^2 = swap b/d
  where isSquare = M2 Refl
instance Square (Squared a b c) c b a -- M3 = M;R^3 = swap a/d, b/c
  where isSquare = M3 Refl

commute :: Square wA wB wC wD => p wA wB -> p wB wC -> (p wA wD, p wD wC)
commute = undefined

merge :: Square wA wB wC wD => p wA wB -> p wA wC -> (p wB wD, p wC wD)
merge = undefined
